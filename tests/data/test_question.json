{
    "Body": "<p>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code.  Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.  </p>\n\n<hr>\n\n<p>(tl;dr version: include the statement: cin.sync_with_stdio(false) or just use fgets instead.</p>\n\n<p>tl;dr results: scroll all the way down to the bottom of my question and look at the table.)</p>\n\n<hr>\n\n<p><strong>C++ code:</strong></p>\n\n<pre><code>#include &lt;iostream&gt;\n#include &lt;time.h&gt;\n\nusing namespace std;\n\nint main() {\n    string input_line;\n    long line_count = 0;\n    time_t start = time(NULL);\n    int sec;\n    int lps;                                                                   \n\n    while (cin) {\n        getline(cin, input_line);\n        if (!cin.eof())\n            line_count++;\n    };\n\n    sec = (int) time(NULL) - start;\n    cerr &lt;&lt; \"Saw \" &lt;&lt; line_count &lt;&lt; \" lines in \" &lt;&lt; sec &lt;&lt; \" seconds.\" ;\n    if (sec &gt; 0) {\n        lps = line_count / sec;\n        cerr &lt;&lt; \"  Crunch speed: \" &lt;&lt; lps &lt;&lt; endl;\n    } else\n        cerr &lt;&lt; endl;\n    return 0;\n}\n\n//Compiled with:\n//g++ -O3 -o readline_test_cpp foo.cpp\n</code></pre>\n\n<p><strong>Python Equivalent:</strong></p>\n\n<pre><code>#!/usr/bin/env python\nimport time\nimport sys\n\ncount = 0\nstart = time.time()\n\nfor line in  sys.stdin:\n    count += 1\n\ndelta_sec = int(time.time() - start_time)\nif delta_sec &gt;= 0:\n    lines_per_sec = int(round(count/delta_sec))\n    print(\"Read {0:n} lines in {1:n} seconds. LPS: {2:n}\".format(count, delta_sec,\n       lines_per_sec))\n</code></pre>\n\n<p><strong>Here are my results:</strong></p>\n\n<pre><code>$ cat test_lines | ./readline_test_cpp \nSaw 5570000 lines in 9 seconds.  Crunch speed: 618889\n\n$cat test_lines | ./readline_test.py \nRead 5570000 lines in 1 seconds. LPS: 5570000\n</code></pre>\n\n<p>Thanks in advance!</p>\n\n<p><strong>Edit:</strong> <em>I should note that I tried this both under OS-X (10.6.8) and Linux 2.6.32 (RHEL 6.2).  The former is a macbook pro, the latter is a very beefy server, not that this is too pertinent.</em></p>\n\n<p><strong>Edit 2:</strong> <em>(Removed this edit, as no longer applicable)</em></p>\n\n<pre><code>$ for i in {1..5}; do echo \"Test run $i at `date`\"; echo -n \"CPP:\"; cat test_lines | ./readline_test_cpp ; echo -n \"Python:\"; cat test_lines | ./readline_test.py ; done\nTest run 1 at Mon Feb 20 21:29:28 EST 2012\nCPP:Saw 5570001 lines in 9 seconds.  Crunch speed: 618889\nPython:Read 5,570,000 lines in 1 seconds. LPS: 5,570,000\nTest run 2 at Mon Feb 20 21:29:39 EST 2012\nCPP:Saw 5570001 lines in 9 seconds.  Crunch speed: 618889\nPython:Read 5,570,000 lines in 1 seconds. LPS: 5,570,000\nTest run 3 at Mon Feb 20 21:29:50 EST 2012\nCPP:Saw 5570001 lines in 9 seconds.  Crunch speed: 618889\nPython:Read 5,570,000 lines in 1 seconds. LPS: 5,570,000\nTest run 4 at Mon Feb 20 21:30:01 EST 2012\nCPP:Saw 5570001 lines in 9 seconds.  Crunch speed: 618889\nPython:Read 5,570,000 lines in 1 seconds. LPS: 5,570,000\nTest run 5 at Mon Feb 20 21:30:11 EST 2012\nCPP:Saw 5570001 lines in 10 seconds.  Crunch speed: 557000\nPython:Read 5,570,000 lines in 1 seconds. LPS: 5,570,000\n</code></pre>\n\n<p><strong>Edit 3:</strong> </p>\n\n<p>Okay, I tried J.N.'s suggestion of trying having python store the line read: but it made no difference to python's speed.  </p>\n\n<p>I also tried J.N.'s suggestion of using scanf into a char array instead of getline into a std::string.  Bingo!  This resulted in equivalent performance for both python and c++. (3,333,333 LPS with my input data, which by the way are just short lines of three fields each, usually about 20 chars wide, though sometimes more).</p>\n\n<p>Code:</p>\n\n<pre><code>char input_a[512];\nchar input_b[32];\nchar input_c[512];\nwhile(scanf(\"%s %s %s\\n\", input_a, input_b, input_c) != EOF) {             \n    line_count++;\n};\n</code></pre>\n\n<p>Speed:</p>\n\n<pre><code>$ cat test_lines | ./readline_test_cpp2 \nSaw 10000000 lines in 3 seconds.  Crunch speed: 3333333\n$ cat test_lines | ./readline_test2.py \nRead 10000000 lines in 3 seconds. LPS: 3333333\n</code></pre>\n\n<p>(Yes, I ran it several times.) So, I guess I will now use scanf instead of getline.  But, I'm still curious if people think this performance hit from std::string/getline is typical and reasonable. </p>\n\n<p><strong>Edit 4 (was: Final Edit / Solution):</strong></p>\n\n<p>Adding:\n    cin.sync_with_stdio(false);</p>\n\n<p>Immediately above my original while loop above results in code that runs faster than Python.  </p>\n\n<p><strong>New performance comparison</strong> (this is on my 2011 Macbook Pro), using the original code, the original with the sync disabled, and the original python, respectively, on a file with 20M lines of text.  Yes, I ran it several times to eliminate disk caching confound.</p>\n\n<pre><code>$ /usr/bin/time cat test_lines_double | ./readline_test_cpp\n       33.30 real         0.04 user         0.74 sys\nSaw 20000001 lines in 33 seconds.  Crunch speed: 606060\n$ /usr/bin/time cat test_lines_double | ./readline_test_cpp1b\n        3.79 real         0.01 user         0.50 sys\nSaw 20000000 lines in 4 seconds.  Crunch speed: 5000000\n$ /usr/bin/time cat test_lines_double | ./readline_test.py \n        6.88 real         0.01 user         0.38 sys\nRead 20000000 lines in 6 seconds. LPS: 3333333\n</code></pre>\n\n<p>Thanks to @Vaughn Cato for his answer!  <strong><em>Any elaboration people can make or good references people can point to as to why this sync happens, what it means, when it's useful, and when it's okay to disable would be greatly appreciated by posterity.</em></strong> :-)</p>\n\n<p><strong>Edit 5 / Better Solution:</strong></p>\n\n<p>As suggested by Gandalf The Gray below, gets is even faster than scanf or the unsynchronized cin approach.  I also learned that <a href=\"http://c-faq.com/stdio/scanfprobs.html\">scanf</a> and <a href=\"http://c-faq.com/stdio/getsvsfgets.html\">gets</a> are both UNSAFE and should NOT BE USED due to potential of buffer overflow.  So, I wrote this iteration using fgets, the safer alternative to gets.  Here are the pertinent lines for my fellow noobs:</p>\n\n<pre><code>char input_line[MAX_LINE];\nchar *result;\n\n//&lt;snip&gt;\n\nwhile((result = fgets(input_line, MAX_LINE, stdin )) != NULL)    \n    line_count++;\nif (ferror(stdin))\n    perror(\"Error reading stdin.\");\n</code></pre>\n\n<p>Now, here are the results using an even larger file (100M lines; ~3.4GB) on a fast server with very fast disk, comparing the python, the unsynced cin, and the fgets approaches, as well as comparing with the wc utility.  [The scanf version segfaulted and I don't feel like troubleshooting it.]:</p>\n\n<pre><code>$ /usr/bin/time cat temp_big_file | readline_test.py \n0.03user 2.04system 0:28.06elapsed 7%CPU (0avgtext+0avgdata 2464maxresident)k\n0inputs+0outputs (0major+182minor)pagefaults 0swaps\nRead 100000000 lines in 28 seconds. LPS: 3571428\n\n$ /usr/bin/time cat temp_big_file | readline_test_unsync_cin \n0.03user 1.64system 0:08.10elapsed 20%CPU (0avgtext+0avgdata 2464maxresident)k\n0inputs+0outputs (0major+182minor)pagefaults 0swaps\nSaw 100000000 lines in 8 seconds.  Crunch speed: 12500000\n\n$ /usr/bin/time cat temp_big_file | readline_test_fgets \n0.00user 0.93system 0:07.01elapsed 13%CPU (0avgtext+0avgdata 2448maxresident)k\n0inputs+0outputs (0major+181minor)pagefaults 0swaps\nSaw 100000000 lines in 7 seconds.  Crunch speed: 14285714\n\n$ /usr/bin/time cat temp_big_file | wc -l\n0.01user 1.34system 0:01.83elapsed 74%CPU (0avgtext+0avgdata 2464maxresident)k\n0inputs+0outputs (0major+182minor)pagefaults 0swaps\n100000000\n\nRecap (lines per second):\npython:         3,571,428 \ncin (no sync): 12,500,000\nfgets:         14,285,714\nwc:            54,644,808\n</code></pre>\n\n<p>As you can see, fgets is better but still pretty far from wc performance; I'm pretty sure this is due to the fact that wc examines each character without any memory copying.  I suspect that, at this point, other parts of the code will become the bottleneck, so I don't think optimizing to that level would even be worthwhile, even if possible (since, after all, I actually need to store the read lines in memory).  </p>\n\n<p>Also note that a small tradeoff with using a char * buffer and fgets vs unsynced cin to string is that the latter can read lines of any length, while the former requires limiting input to some finite number.  In practice, this is probably a non-issue for reading most line-based input files, as the buffer can be set to a very large value that would not be exceeded by valid input. </p>\n\n<p>This has been educational.  Thanks to all for your comments and suggestions.</p>\n\n<p><strong>Edit 6:</strong></p>\n\n<p>As suggested by J.F. Sebastian in the comments below, the GNU wc utility uses plain C read() (within the safe-read.c wrapper) to read chunks (of 16k bytes) at a time and count new lines.  Here's a python equivalent based on J.F.'s code (just showing the relevant snippet that replaces the python for loop:</p>\n\n<pre><code>BUFFER_SIZE = 16384 \ncount = sum(chunk.count('\\n') for chunk in iter(partial(sys.stdin.read, BUFFER_SIZE), ''))\n</code></pre>\n\n<p>The performance of this version is quite fast (though still a bit slower than the raw c wc utility, of course:</p>\n\n<pre><code>$ /usr/bin/time cat temp_big_file | readline_test3.py \n0.01user 1.16system 0:04.74elapsed 24%CPU (0avgtext+0avgdata 2448maxresident)k\n0inputs+0outputs (0major+181minor)pagefaults 0swaps\nRead 100000000 lines in 4.7275 seconds. LPS: 21152829\n</code></pre>\n\n<p>Again, it's a bit silly for me to compare C++ fgets/cin and the first python code on the one hand to wc -l and this last python snippet on the other, as the latter two don't actually store the read lines but merely count newlines.  Still, it's interesting to explore all the different implementations and think about the performance implications.  Thanks again!</p>\n\n<p><strong>Edit 7: Tiny benchmark addendum and recap</strong></p>\n\n<p>(Hello HN readers!)   </p>\n\n<p>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code.  Again, this is for a 100M line file on a fast disk. Here's the complete table now:</p>\n\n<pre><code>Implementation      Lines per second\npython (default)           3,571,428\ncin (default/naive)          819,672\ncin (no sync)             12,500,000\nfgets                     14,285,714\nwc (not fair comparison)  54,644,808\n</code></pre>\n\n<p>Also, see my follow-up <a href=\"http://stackoverflow.com/questions/9378500/why-is-splitting-a-string-slower-in-c-than-python\">question</a> about splitting lines in C++ vs Python... a similar speed story, where the naive approach is slower in C++!</p>\n\n<p>Edit: for clarity, removed tiny bug in original code that wasn't related to the question.</p>\n", 
    "ViewCount": 80131, 
    "_id": "53826e34421aa964b69a6c27",
    "Tags": [
        "c++", 
        "python", 
        "benchmarking", 
        "readline", 
        "getline"
    ], 
    "LastEditorUserId": 379037, 
    "LastActivityDate": 1398264984480,
    "LastEditDate": 1389804296950,
    "AnswerCount": 12, 
    "CommentCount": 26, 
    "AcceptedAnswerId": 9371717, 
    "Score": 497, 
    "CommunityOwnedDate": 1339614199460,
    "Title": "Why is reading lines from stdin much slower in C++ than Python?", 
    "PostTypeId": 1, 
    "OwnerUserId": 379037, 
    "CreationDate": 1329790670463,
    "FavoriteCount": 318, 
    "Id": 9371238
}
